package javaApplication;
import java.util.*;

public class Sorts {
    public static void main(String args[])
    {
    long starttime,stoptime;
    List<Integer> arr=new ArrayList<Integer>();
    Sorts obj=new Sorts();
   
    arr=File_Reader.main(null);
    
    Integer temp[]=new Integer[arr.size()];
    
    int input[]=new int[temp.length];
    temp=arr.toArray(temp);
    for(int i=0;i<temp.length;i++)
    {
    	input[i]=temp[i].intValue();
    }
    //System.out.println("Before sort "+arr);
    
    starttime=System.currentTimeMillis();
    
    input=obj.radixSort(input);
    stoptime=System.currentTimeMillis();
    
    //Merge Sort
    
   
    System.out.println("After sort "+Arrays.toString(input));
    System.out.println("After sort "+arr);
    System.out.println(stoptime-starttime);
    
    
    }

    public List<Integer> bubbleSort(List<Integer> input)       
    {
        int temp=0;
        for(int i=0;i<(input.size()-1);i++)
        {
            for(int j=1;j<(input.size()-i);j++)
            {
                if(input.get(j-1)> input.get(j))
                {
                    temp=input.get(j-1);
                    input.set(j-1,input.get(j));
                    input.set(j,temp);
                }
            }
        }
        return input;
        
    }
   
    public List<Integer> insertionSort(List <Integer> input)
    {
       
        int j;
        for(int i= 1;i<input.size();i++)
        {
            j=i-1;
            int key=input.get(i);
            while((j>-1)&&(input.get(j)> key ))
            {
                input.set(j+1,input.get(j));
                j--;
            }
            input.set(j+1,key);
            
            
        }
        return input;
    }
    
    public List<Integer> selectionSort(List <Integer> input)
    {
    	 for (int i = 0; i < input.size() - 1; i++)
         {
             int index = i;
             for (int j = i + 1; j < input.size(); j++)
             {
                 if (input.get(j) < input.get(index))
                     index = j;
             }
       
             int smallerNumber = input.get(index); 
             input.set(index,input.get(i));
             input.set(i,smallerNumber);
         }
         return input;
    }
    
    public int[] mergeSort(int [] list) {
        if (list.length <= 1) {
            return list;
        }
        
        // Split the array in half
        int[] first = new int[list.length / 2];
        int[] second = new int[list.length - first.length];
        System.arraycopy(list, 0, first, 0, first.length);
        System.arraycopy(list, first.length, second, 0, second.length);
        
        // Sort each half
        mergeSort(first);
        mergeSort(second);
        
        // Merge the halves together, overwriting the original array
        merge(first, second, list);
        return list;
    }
    
    private void merge(int[] first, int[] second, int [] result) {
        // Merge both halves into the result array
        // Next element to consider in the first array
        int iFirst = 0;
        // Next element to consider in the second array
        int iSecond = 0;
        
        // Next open position in the result
        int j = 0;
        // As long as neither iFirst nor iSecond is past the end, move the
        // smaller element into the result.
        while (iFirst < first.length && iSecond < second.length) {
            if (first[iFirst] < second[iSecond]) {
                result[j] = first[iFirst];
                iFirst++;
                } else {
                result[j] = second[iSecond];
                iSecond++;
            }
            j++;
        }
        // copy what's left
        System.arraycopy(first, iFirst, result, j, first.length - iFirst);
        System.arraycopy(second, iSecond, result, j, second.length - iSecond);
    }
    
    public int[] radixSort( int[] a)
    {
        int i, m = a[0], exp = 1, n = a.length;
        int[] b = new int[10];
        for (i = 1; i < n; i++)
            if (a[i] > m)
                m = a[i];
        while (m / exp > 0)
        {
            int[] bucket = new int[10];
 
            for (i = 0; i < n; i++)
                bucket[(a[i] / exp) % 10]++;
            for (i = 1; i < 10; i++)
                bucket[i] += bucket[i - 1];
            for (i = n - 1; i >= 0; i--)
                b[--bucket[(a[i] / exp) % 10]] = a[i];
            for (i = 0; i < n; i++)
                a[i] = b[i];
            exp *= 10;        
        }
        return a;
    }    
}